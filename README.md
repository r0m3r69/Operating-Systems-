# Operating-Systems-

CS 230 Module Eight Journal: Software Design Reflection
Client Summary:
The client for this project was The Gaming Room, a company with an existing Android game called Draw It or Lose It. They wanted to expand the game into a web-based, multi-platform application that could support multiple teams and players. Their main requirements included a scalable, distributed design, strict uniqueness for team and game names, centralized memory management, and security for cross-platform communication.

What I Did Well:
One of the things I did particularly well was documenting the design in a clear and organized manner. I was intentional about using professional language, explaining technical concepts like memory management and security practices in a way that would make sense to both developers and clients. I also tied every design decision back to the client's goals.

Helpful Parts of the Process:
Working through the design document helped me better understand the structure of a software application before writing code. It gave me a roadmap for how different components would interact, which is something I’ll continue to use in future development work. It made the coding phase more straightforward and less prone to rework.

What I’d Improve:
If I could revise one part, I would polish my earlier UML diagrams to better reflect design patterns and object relationships. I would also use a diagramming tool to make the visuals cleaner and more professional, which helps with communication and clarity.

Understanding User Needs:
I interpreted user needs by focusing heavily on requirements like cross-platform compatibility, team scalability, and security. I made sure the architecture supported mobile and desktop users equally and built in safeguards like authentication and encrypted communication. Understanding user needs early ensured my technical solutions were actually solving real problems.

Design Strategy:
My approach to software design was grounded in modular, object-oriented thinking. I used inheritance, encapsulation, and design patterns like Singleton and Iterator to manage the game state and enforce constraints. In the future, I’d also use prototyping or UI mockups earlier to visualize user interactions more clearly. Tools like flowcharts and class diagrams also proved valuable for planning.
